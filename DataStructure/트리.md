# 트리

트리(Tree)는 노드(Node)로 구성된 계층적인 데이터 구조입니다.
- 하나의 루트 노드(Root Node)가 있다.
- 루트 노드 아래에는 0개 이상의 자식 노드(Child Nodes)가 있다.
- 각 자식 노드 아래에도 0개 이상의 자식 노드가 존재하며, 이를 반복한다.
- 순환 구조를 갖지 않는다.
- 노드들은 특정한 순서(예: 왼쪽 또는 오른쪽 자식 노드)로 배치될 수 있다.


## 이진 트리(Binary Tree)

: 각 노드가 최대 두 개의 자식(왼쪽과 오른쪽)을 가지는 트리.

- 장점: 기본적인 트리 구조로, 이해하기 쉽다.
- 단점: 편향된 트리가 생성될 경우 검색 및 삽입 시간이 증가한다.
- 사례: 간단한 트리 구조를 표현할 때 사용.

## 이진 탐색 트리(Binary Search Tree, BST)

: 이진 트리의 일종. 노드의 왼쪽 서브 트리에는 해당 노드의 값보다 작은 값들을, 오른쪽 서브 트리에는 해당 노드의 값보다 큰 값들을 저장하는 구조.

- 장점: 평균의 경우 O(log n)의 시간 복잡도로 데이터 검색 및 삽입이 가능하다.
- 단점: 편향된 트리가 되면 최악의 경우 O(n)의 시간이 걸릴 수 있다.
- 사례: 탐색 작업이 빈번하게 이루어지는 경우.

##  AVL 트리

: 이진 탐색 트리의 일종. 균형 조건을 만족하기 위해 회전 연산을 수행하는 자가 균형 이진 탐색 트리.

- 장점: 트리의 균형을 유지하여 검색, 삽입, 삭제 모두 O(log n)의 시간 복잡도를 보장한다.
- 단점: 삽입 및 삭제 연산이 복잡하며, 회전 연산 때문에 오버헤드가 발생할 수 있다.
- 사례: 균형이 유지되어야 하는 이진 탐색 트리가 필요한 경우.

##  레드-블랙 트리(Red-Black Tree)

: 이진 탐색 트리의 일종. 노드에 색깔(레드 또는 블랙)을 부여하여 균형을 유지하는 자료구조.
- 장점: 삽입, 삭제, 검색 모두 O(log n)의 시간 복잡도를 갖는다.
- 단점: 구현이 복잡하다.
- 사례: Java의 TreeMap, TreeSet 등에서 사용됨.

##  B-트리(B-Tree)

: 외부 노드 탐색이 필요한 데이터 저장 시스템에서 사용되는 균형 이진 트리.
- 장점: 데이터베이스 및 파일 시스템과 같은 디스크 기반 저장 시스템에서 높은 성능을 제공한다.
- 단점: 메모리 기반의 시스템에서는 오버헤드가 발생할 수 있다.
- 사례: 파일 시스템 및 데이터베이스의 인덱싱에 사용.