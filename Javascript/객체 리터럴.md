# 변수

- [객체 리터럴](#객체-리터럴)
  - [자바스크립트에서 객체란 뭘까요?](#자바스크립트에서-객체란-뭘까요)
  - [함수와 메서드의 차이점에 대해 알고 계신가요?](#함수와-메서드의-차이점에-대해-알고-계신가요)
  - [자바스크립트에서 객체를 생성하는 방법은 어떤 것들이 있나요?](#자바스크립트에서-객체를-생성하는-방법은-어떤-것들이-있나요)
  - [객체를 삭제하는 방법은?](#객체를-삭제하는-방법은)
  - [function이 있는데 왜 메소드를 쓰나요?](#function이-있는데-왜-메소드를-쓰나요)
  - [객체지향 프로그래밍이란?](#객체지향-프로그래밍이란)
  - [💡 출처](#-출처)

---
## <span style='background-color: #fff5b1; color: black'>자바스크립트에서 객체란 뭘까요?</span>
자바스크립트를 이루고 있는 거의 "모든 것"이 객체입니다. 원시 타입(Primitives)을 제외한 나머지 값들(함수, 배열, 정규표현식 등)은 모두 객체입니다.

자바스크립트의 객체는 키(key)과 값(value)으로 구성된 프로퍼티(Property)들의 집합입니다. 프로퍼티의 값으로 자바스크립트에서 사용할 수 있는 모든 값을 사용할 수 있습니다.

자바스크립트의 객체는 객체지향의 상속을 구현하기 위해 "프로토타입(prototype)"이라고 불리는 객체의 프로퍼티와 메소드를 상속받을 수 있습니다. 이 [프로토타입](https://www.nextree.co.kr/p7323/)은 타 언어와 구별되는 중요한 개념입니다.


## <span style='background-color: #fff5b1; color: black'>함수와 메서드의 차이점에 대해 알고 계신가요?</span>
함수와 메서드는 둘 다 자바스크립트에서 코드 블록을 실행하기 위한 방법입니다. 그러나 메서드는 객체 내에서 정의되며, 해당 객체의 컨텍스트에서 실행됩니다. 반면 함수는 객체와 독립적으로 실행될 수 있습니다.<br>

### **함수 (Function)**

1. **정의**: 자바스크립트에서 함수는 재사용 가능한 코드 블록입니다.
2. **위치**: 함수는 자바스크립트의 어느 곳에서나 선언될 수 있습니다. 객체 외부에서도 선언할 수 있습니다.
3. **호출**: 함수는 그냥 이름으로 호출될 수 있습니다.
4. **예제**:

    ```jsx
    function greet() {
        console.log("안녕하세요!");
    }

    greet();  // 출력: 안녕하세요!

    ```


### **메서드 (Method)**

1. **정의**: 메서드는 객체 내부에서 정의된 함수입니다.
2. **위치**: 메서드는 객체 내부에서만 정의됩니다.
3. **호출**: 메서드는 해당 객체를 통해서 호출됩니다.
4. **예제**:

    ```jsx
    let person = {
        name: "홍길동",
        greet: function() {
            console.log("안녕하세요, " + this.name + "입니다!");
        }
    }

    person.greet();  // 출력: 안녕하세요, 홍길동입니다!

    ```


### **주요 차이점**

1. **this의 값**:
    - **함수**에서 **this**는 일반적으로 전역 객체(브라우저에서는 **window**)를 참조하거나, 엄격 모드(**strict mode**)에서는 **undefined**입니다.
    - **메서드**에서 **this**는 그 메서드를 포함하는 객체를 참조합니다.
2. **정의 위치**:
    - 함수는 객체와 관계 없이 어디서든 정의될 수 있습니다.
    - 메서드는 객체 내부에서만 정의됩니다.


## <span style='background-color: #fff5b1; color: black'>자바스크립트에서 객체를 생성하는 방법은 어떤 것들이 있나요?</span>
### **1. 객체 리터럴을 사용한 생성**

가장 간단하고 자주 사용되는 방법입니다. 중괄호 **{}**를 사용하여 객체를 직접 정의합니다.

```jsx
let person = {
    name: "홍길동",
    age: 25
};

```

### **2. new Object()를 사용한 생성**

**new** 키워드와 함께 **Object()** 생성자를 사용하여 객체를 생성할 수 있습니다.

```jsx
let person = new Object();
person.name = "홍길동";
person.age = 25;

```

### **3. 생성자 함수를 사용한 생성**

사용자 정의 생성자 함수를 통해 객체를 생성할 수 있습니다. 일반적으로 생성자 함수의 이름은 대문자로 시작합니다.

```jsx
function Person(name, age) {
    this.name = name;
    this.age = age;
}

let person1 = new Person("홍길동", 25);
let person2 = new Person("이순신", 45);

```

### **4. Object.create()를 사용한 생성**

**Object.create()** 메서드를 사용하면 특정 프로토타입을 상속받는 새로운 객체를 생성할 수 있습니다.

```jsx
let personPrototype = {
    greet: function() {
        console.log("안녕하세요, " + this.name + "입니다!");
    }
};

let person = Object.create(personPrototype);
person.name = "홍길동";
person.greet();  // 출력: 안녕하세요, 홍길동입니다!

```

### **5. Object.assign()를 사용한 생성**

**Object.assign()** 함수를 사용하여 하나 이상의 객체를 결합하여 새로운 객체를 생성할 수 있습니다.

```jsx
var person1 = {
  firstName: "John"
};

var person2 = {
  lastName: "Doe"
};

var person = Object.assign({}, person1, person2);

```

### **6. ES6 클래스를 사용한 생성**

ES6에서 도입된 **class** 키워드를 사용하여 객체를 생성할 수 있습니다.

```jsx
javascriptCopy code
class Person {
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }

    greet() {
        console.log("안녕하세요, " + this.name + "입니다!");
    }
}

let person = new Person("홍길동", 25);
person.greet();  // 출력: 안녕하세요, 홍길동입니다!

```


## <span style='background-color: #fff5b1; color: black'>객체를 삭제하는 방법은?</span>
자바스크립트에서 객체 자체를 직접 삭제하는 것은 불가능합니다. 하지만 객체의 속성(프로퍼티)을 삭제하는 것은 가능합니다. 그리고 객체에 대한 참조를 없애면 가비지 컬렉션(garbage collection)에 의해 객체는 메모리에서 제거될 수 있습니다.

1. **객체의 프로퍼티 삭제하기**:
**delete** 연산자를 사용하여 객체의 특정 프로퍼티를 삭제할 수 있습니다.

    ```jsx
    javascriptCopy code
    let person = {
      name: "John",
      age: 30
    };

    delete person.age;  // person 객체에서 'age' 프로퍼티를 삭제합니다.

    console.log(person); // { name: "John" }

    ```

    **delete**를 사용하면 해당 프로퍼티와 그 값을 객체에서 완전히 제거합니다.

2. **객체에 대한 참조 제거**:
객체 자체를 직접 삭제할 수는 없지만, 객체에 대한 모든 참조를 제거하면 해당 객체는 가비지 컬렉션의 대상이 됩니다. 이는 자바스크립트 엔진이 사용하지 않는 메모리를 자동으로 회수하는 메커니즘입니다.

    ```jsx
    javascriptCopy code
    let person = {
      name: "John",
      age: 30
    };

    person = null; // person 변수의 참조를 제거합니다.

    ```

    위 코드에서 **person** 객체에 대한 참조를 **null**로 설정하여 참조를 제거하였습니다. 만약 이 객체를 참조하는 다른 변수나 속성이 없다면, 가비지 컬렉션에 의해 메모리에서 제거될 것입니다.


## <span style='background-color: #fff5b1; color: black'>function이 있는데 왜 메소드를 쓰나요?</span>
메서드는 객체 지향 프로그래밍의 핵심 원칙 중 하나인 캡슐화를 구현하는 데 중요한 도구입니다. 객체의 상태와 관련된 로직을 한데 묶어 코드의 조직성을 높이고, 재사용성을 높이며, 사용자에게 간결하고 표현적인 API를 제공합니다.

### 메서드를 사용하는 주요 이유와 그 장점

  - **캡슐화(Encapsulation)**: 메서드는 객체의 내부 상태와 관련된 로직을 한데 묶습니다. 이를 통해 객체의 상태와 행동이 밀접하게 연결되어 있음을 나타내며, 코드를 조직적이고 관리하기 쉽게 만듭니다.

  - **this 키워드 사용**: 메서드 내에서 this를 사용하면 해당 객체에 접근할 수 있습니다. 이를 통해 메서드는 객체의 현재 상태를 참조하고 수정할 수 있습니다. 반면 일반 함수에서 this는 실행 컨텍스트에 따라 다르게 동작합니다.

  - **재사용성(Reusability)**: 객체의 프로토타입에 메서드를 정의하면, 그 객체의 모든 인스턴스가 해당 메서드를 공유하게 됩니다. 이를 통해 메모리를 효율적으로 사용할 수 있으며, 모든 인스턴스에서 동일한 메서드 로직을 활용할 수 있습니다.

  - **추상화(Abstraction)**: 메서드를 사용하면, 객체의 복잡한 내부 로직을 추상화하여 사용자에게 단순한 API를 제공할 수 있습니다. 사용자는 객체가 어떻게 동작하는지 알 필요 없이, 메서드를 호출함으로써 원하는 기능을 수행할 수 있습니다.

  - **표현성**: 메서드를 사용하면, 해당 객체와 관련된 행동을 표현적으로 나타낼 수 있습니다. 예를 들어, array.push(item)은 배열에 항목을 추가하는 행동을 명확하게 나타냅니다.


## <span style='background-color: #fff5b1; color: black'>객체지향 프로그래밍이란?</span>
객체지향 프로그래밍(Object-Oriented Programming, OOP)은 컴퓨터 프로그래밍의 패러다임 중 하나로, '객체'라는 개념을 중심으로 코드를 구조화하는 방식입니다. 객체는 프로그램에서 사용되는 데이터 또는 식별자에 의해 참조되는 공간을 의미하며 값을 저장 할 변수와 작업을 수행 할 메소드를 서로 연관된 것들끼리 묶어서 만든 것을 객체라고 할 수 있습니다. 객체지향 프로그래밍은 이러한 객체들 사이의 상호작용을 통해 프로그램을 설계하고 구현하는 접근 방식입니다. 객체지향 프로그래밍을 레고에 빗대 표현 할 수 있는데, 객체가 레고의 조각이 될 것이고 레고의 조각을 조립해서 무언가를 만드는 방식이 객체지향 프로그래밍이라고 할 수 있다.



### 객체지향 프로그래밍의 핵심 원칙과 개념

1. **객체(Object)**: 속성(properties)와 메서드(methods)를 갖는 독립적인 단위입니다. 예를 들어, '사람' 객체는 '이름', '나이'와 같은 속성 및 '걷다', '말하다'와 같은 메서드를 가질 수 있습니다.
2. **클래스(Class)**: 객체를 생성하기 위한 템플릿 또는 설계도입니다. 클래스는 객체의 구조와 해당 객체가 할 수 있는 행동을 정의합니다.
3. **상속(Inheritance)**: 한 클래스가 다른 클래스의 속성과 메서드를 상속받아 사용할 수 있게 합니다. 이를 통해 코드의 재사용성이 증가하고, 계층적 구조를 갖는 데이터 모델을 설계할 수 있습니다.
4. **캡슐화(Encapsulation)**: 객체의 내부 데이터와 그 데이터를 처리하는 메서드를 하나로 묶어서 외부로부터의 직접적인 접근을 제한하는 것입니다. 이를 통해 데이터의 무분별한 수정을 방지하고, 객체의 내부 동작 방식을 숨길 수 있습니다.
5. **다형성(Polymorphism)**: 동일한 인터페이스를 갖는 여러 객체가 다양한 방식으로 해당 인터페이스를 구현하는 것을 의미합니다. 예를 들어, '동물' 클래스를 상속받은 '고양이'와 '강아지' 클래스가 '울다'라는 메서드를 각기 다르게 구현할 수 있습니다.
6. **추상화(Abstraction)**: 복잡한 시스템을 단순한 개념으로 표현하는 것입니다. 사용자는 객체의 내부 구현 방식을 알 필요 없이 해당 객체가 제공하는 기능만을 사용할 수 있습니다.

객체지향 프로그래밍의 주요 장점은 코드의 재사용성, 확장성, 유지보수성이 높아진다는 것입니다. 실제 세계의 다양한 개체와 시스템을 모델링하는 데 더 자연스러운 접근 방식을 제공하며, 큰 프로젝트나 복잡한 시스템에서 특히 그 장점이 두드러집니다.


---
### 💡 출처
- [JavaScript - 생성자 함수에 의한 객체 생성](https://velog.io/@minj9_6/JavaScript-생성자-함수에-의한-객체-생성)
- [객체를 생성하는 3가지 방법](https://leehwarang.github.io/docs/tech/constructor.html)
- [PoiemaWeb](https://poiemaweb.com/js-object)
- [JavaScript : 프로토타입(prototype) 이해](https://www.nextree.co.kr/p7323/)
- [객체지향 프로그래밍이란?](https://jongminfire.dev/객체지향-프로그래밍이란)