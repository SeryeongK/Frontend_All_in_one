# 변수

- [변수](#변수)
  - [변수란 무엇인가요?](#변수란-무엇인가요)
  - [식별자는 무엇인가요?](#식별자는-무엇인가요)
  - [var let const 차이점](#var-let-const-차이점)
  - [const 키워드는 어떤 특징이 있나요?](#const-키워드는-어떤-특징이-있나요)
  - [변수를 선언한다는 것은 어떤 것을 의미하나요?](#변수를-선언한다는-것은-어떤-것을-의미하나요)
  - [호이스팅이 뭔가요?](#호이스팅이-뭔가요)
  - [var 키워드의 문제점은 무엇이 있나요?](#var-키워드의-문제점은-무엇이-있나요)
  - [식별자 네이밍 규칙은 어떤 것들이 있나요?](#식별자-네이밍-규칙은-어떤-것들이-있나요)
  - [네이밍 컨벤션은 어떤 것들이 있나요?](#네이밍-컨벤션은-어떤-것들이-있나요)
  - [식별자 네이밍 규칙은 어떤 것들이 있나요?](#식별자-네이밍-규칙은-어떤-것들이-있나요)
  - [리터럴이 뭔가요?](#리터럴이-뭔가요)
    - [💡 출처](#-출처)

---
## <span style='background-color: #fff5b1; color: black'>변수란 무엇인가요?</span>
변수(variable)란 데이터를 저장할 수 있는 메모리 공간 또는 저장 공간의 이름이다.<br>

상자에 물건을 넣어두면 나중에 그 물건을 다시 찾아서 사용할 수 있듯이, 프로그래밍에서 변수도 마찬가지로 어떤 값을 저장하고, 필요할 때 그 값을 꺼내서 사용합니다.

## <span style='background-color: #fff5b1; color: black'>식별자는 무엇인가요?</span>
변수의 이름을 식별자(identifier)라고도 한다. 변수, 함수, 클래스, 모듈 등을 구별하기 위해 프로그래머가 지정하는 이름이다. 식별자는 값이 아니라 메모리 주소를 기억하고 있다.<br>

## <span style='background-color: #fff5b1; color: black'>var let const 차이점</span>
- var 선언은 전역 범위 또는 함수 범위이며, let 및 const는 블록 범위이다.
- var 변수는 범위 내에서 업데이트하고 다시 선언 할 수 있다. (재선언 O, 재할당 O)
- let 변수는 업데이트 할 수 있지만 다시 선언 할 수 없다. (재선언 X, 재할당 O)
- const 변수는 업데이트하거나 다시 선언 할 수 없다. (재선언 X, 재할당 X)

## <span style='background-color: #fff5b1; color: black'>const 키워드는 어떤 특징이 있나요?</span>
  - 한번 선언하게되면 절대로 그 값은 변경 불가능하다.
  - 상자 포장을 겁나 빡세게 해서 영구적으로 밀봉해버리면 프로그램 실행 중에 변경할수 없다. 즉, 재할당이 불가능하다.
  - 자바스크립트에서 상수 선언은 const로 한다.

## <span style='background-color: #fff5b1; color: black'>변수를 선언한다는 것은 어떤 것을 의미하나요?</span>
변수를 선언한다는 것은 값을 저장하기 위한 메모리 값을 확보하고, 변수 이름과 확보한 메모리 공간의 주소를 연결하는 것이다. 즉,  변수명과 매핑하고자 하는 데이터의 메모리 주소를 저장할 또하나의 메모리공간을 확보하는 것이다.
  - 변수를 사용하기 위해서는 꼭 선언이 필요하다.
  - 자바스크립트에서는 var, let, const 키워드를 사용한다.
  - 선언단계 : 변수이름을 등록, 변수의 존재를 알림.
  - 초기화단계 : 메모리 공간을 확보, undefined를 할당해 초기화
    - 초기화 단계라고 부르는 이유는 이전에 저장되었던 데이터가 남아있을 수 있는 것을 초기화하는 동작을 진행하기 때문이다.

## <span style='background-color: #fff5b1; color: black'>호이스팅이 뭔가요?</span>
JavaScript에서 호이스팅(hoisting)이란, 인터프리터가 변수와 함수의 메모리 공간을 선언 전에 미리 할당하는 것을 의미한다. var로 선언한 변수의 경우 호이스팅 시 undefined로 변수를 초기화한다. 반면 let과 const로 선언한 변수의 경우 호이스팅 시 변수를 초기화하지 않는다.<br>

호이스팅을 설명할 땐 주로 "변수의 선언과 초기화를 분리한 후, 선언만 코드의 최상단으로 옮기는" 것으로 말하곤 한다. 따라서 변수를 정의하는 코드보다 사용하는 코드가 앞서 등장할 수 있다. 다만 선언과 초기화를 함께 수행하는 경우, 선언 코드까지 실행해야 변수가 초기화된 상태가 됨을 주의해야한다.<br>

  - 호이스팅은 코드를 실행하기 전 변수선언/함수선언을 해당 스코프의 최상단으로 끌어올리는 것이 아니다.
  - 호이스팅은 코드가 실행하기 전 변수선언/함수선언이 해당 스코프의 최상단으로 끌어 올려진 것 같은 현상을 말한다.
  - 자바스크립트 엔진은 코드를 실행하기 전 실행 가능한 코드를 형상화하고 구분하는 과정(*실행 컨텍스트를 위한 과정)을 거친다.
  - 자바스크립트 엔진은 코드를 실행하기 전 실행 컨텍스트를 위한과정에서 모든 선언(var, let, const, function, class)을 스코프에 등록한다.
  - 코드 실행 전 이미 변수선언/함수선언이 저장되어 있기 때문에 선언문보다 참조/호출이 먼저 나와도 오류 없이 동작한다. (정확히는 var 키워드로 선언한 변수와 함수 선언문일 경우 오류 없이 동작한다. 이는 선언이 파일의 맨 위로 끌어올려진 것 처럼 보이게 한다.)
  - *실행 컨텍스트는 실행 가능한 코드가 실행되기 위해 필요한 환경을 의미하고 실행되기전 이러한 실행 컨텍스트 과정(코드를 구분하는 과정)을 거친다.
  - 자바스크립트의 모든 선언에는 호이스팅이 일어난다.
  - 그런데 let, const, class를 이용한 선언문을 호이스팅이 발생하지 않는 것처럼 동작한다.
  - var 키워드로 선언된 변수와는 달리 let 키워드로 선언된 변수를 선언문 이전에 참조하면 참조 에러(ReferenceError)가 발생한다.
  - 이는 let 키워드로 선언된 변수는 스코프의 시작에서 변수의 선언까지 *일시적 사각지대(Temporal Dead Zone; TDZ)에 빠지기 때문이다.

### <span style='background-color: #fff5b1; color: black'>변수는 어떻게 생성될까?</span>
1단계 : 선언 단계(Declaration phase)
  - 변수를 실행 컨텍스트의 변수 객체에 등록한다
  - 이 변수 객체는 스코프가 참조하는 대상이 된다.
<br>

2단계 : 초기화 단계(Initialization phase)
  - 변수 객체에 등록된 변수를 위한 공간을 메모리에 확보한다.
  - 이 단계에서 변수는 undefined로 초기화 된다.
<br>

3단계 : 할당 단계(Assignment phase)
  - undefined로 초기화된 변수에 실제 값을 할당한다.

### <span style='background-color: #fff5b1; color: black'>호이스팅은 어떻게 이뤄질까?</span>
var 키워드로 선언한 변수는 선언 단계와 초기화 단계가 한번에 이뤄진다. 즉, 스코프에 변수를 등록(선언 단계)하고 메모리에 변수를 위한 공간을 확보한 후, undefined로 초기화한다. 따라서 변수 선언문 이전에 변수에 접근해도 스코프에 변수가 존재하기 때문에 에러가 발생하지 않는다. 다만 undefined를 반환한다. 이후 변수 할당문에 도달하면 비로소 값이 할당된다. <br>

let 키워드로 선언된 변수는 선언 단계와 초기화 단계가 분리되어 진행된다. 즉, 스코프에 변수를 등록(선언 단계)하지만 초기화 단계는 변수 선언문에 도달했을 때(코드 실행 후) 이뤄진다. 초기화 이전에 변수에 접근하려고 하면 참조 에러가 발생한다. 이는 아직 변수가 초기화되지 않았기 때문이다. 즉, 변수를 위한 메모리 공간이 아직 확보되지 않았기 때문이다. 따라서 스코프의 시작 지점부터 초기화 시작 지점까지는 변수를 참조할 수 없다. 스코프의 시작 지점부터 초기화 시작 지점까지의 구간을 '일시적 사각지대(Temporal Dead Zone; TDZ)'라고 부른다.

### <span style='background-color: #fff5b1; color: black'>var 키워드의 문제점은 무엇이 있나요?</span>
var는 변수의 재선언, 재할당 모두가 가능하기 때문에 유연한 변수이다. 하지만 코드양이 많아질수록 유지 관리가 힘들며 에러를 찾기도 힘들어진다.

## <span style='background-color: #fff5b1; color: black'>식별자 네이밍 규칙은 어떤 것들이 있나요?</span>
자바스크립트(Javascript)에서는 다음과 같은 네이밍 규칙이 존재한다.
- 식별자는 문자, 숙자, 언더 스코어(_)와 특수문자에서는 유일하게 $이를 포함하여 사용할 수 있다.<br>
  (다른 특수문자는 사용할 수 없다. ex. ＃, ★, ※ ,...)
- 식별자는 숫자로 시작할 수 없다.
- 식별자는 예약어로 분리되는 이름들을 사용할 수 없다.<br>
  [ ex) break, if, void, with, try, var 등등 ]
- 변수는 쉼표(,)를 활용하여 여러 개를 한 번에 선언할 수 있다. 하지만 가독성이 낮아지는 선언이므로 가급적 지양한다.

## <span style='background-color: #fff5b1; color: black'>네이밍 컨벤션은 어떤 것들이 있나요?</span>
```js
// lower 카멜 케이스
var camelCase

// 파스칼 케이스
var PascalCase

// 스네이크 케이스
var snake_case
```

## <span style='background-color: #fff5b1; color: black'>리터럴이 뭔가요?</span>
리터럴이란 사람이 이해할 수 있는 문자 또는 미리 약속된 기호로 표기한 코드이다. 리터럴은 값으로 평가되며 따라서 리터럴도 표현식이라 할 수 있다. (값으로 평가될 수 있는 것은 모두 표현식)
  - 리터럴(literal) 은 자바스크립트에서 객체와 배열을 정의하는 간단한 방법이다. 즉, 고정된 값을 나타나는 표현 그 자체가 리터럴이다.
  - 리터럴의 종류 : 정수 리터럴, 부동소수점 리터럴, 2진수 리터럴, 8진수 리터럴, 16진수 리터럴, 문자열 리터럴, 불리언 리터럴, null 리터럴, undefined 리터럴, 객체 리터럴, 배열 리터럴, 함수 리터럴, 정규 표현식 리터럴, 템플릿 리터럴(ES6부터 도입 ex.``(백틱))


---
### 💡 출처
- [[JavaScript] 호이스팅(Hoisting)이란? - 하나몬](https://hanamon.kr/javascript-호이스팅이란-hoisting/)
- [[JavaScript/자바스크립트] 리터럴과 타입](https://hans-j.tistory.com/83)
- [리터럴(Literal)이란?](https://velog.io/@me2designer/리터럴Literal이란)
- [[자바스크립트] 리터럴(literal) 쉽게 이해하기 편. with javascript](https://tiboy.tistory.com/685)
- [[기술 면접 대비] var, let, const의 차이점과 Hoisting](https://velog.io/@elma98/기술-면접-대비-var-let-const의-차이점과-Hoisting)
- [var let const, 그리고 호이스팅](https://yceffort.kr/2020/05/var-let-const-hoisting)
- [[자바스크립트] 변수란 ???](https://velog.io/@jh100m1/변수란)
- [[JavaScript] 변수란? - 하나몬](https://hanamon.kr/javascript-변수란/)
- [[JavaScript] 변수(Variable)](https://thisiscoke.tistory.com/entry/JavaScript-변수Variable)